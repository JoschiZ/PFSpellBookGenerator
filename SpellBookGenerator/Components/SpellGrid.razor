@using System.Collections.ObjectModel
@using FuzzySharp
@using SpellBookGenerator.Core.Spells
@using Shared
@inject ISnackbar Snackbar
@typeparam TSpell where TSpell: ISpell
@typeparam TDisplay where TDisplay: ISpellDisplay<TSpell>

<MudDataGrid 
    ReadOnly="false" 
    EditMode="DataGridEditMode.Form" 
    @ref="@_spellGrid" 
    Groupable 
    GroupExpanded="false"
    Items="@Spells"
    Filterable
    FilterCaseSensitivity="DataGridFilterCaseSensitivity.Ignore"
    FilterMode="DataGridFilterMode.Simple"
>
    <Columns>
        <HierarchyColumn/>
        <PropertyColumn Title="Level" IsEditable Property="arg => arg.CurrentSpellLevel" Grouping GroupBy="spell => spell.CurrentSpellLevel">
            <FilterTemplate>
                <MudTextField T="string" ValueChanged="@((string value) => OnFilterChanged(value, nameof(ISpell.Name)))"/>
                <MudButton OnClick="@(() => ApplyFilterAsync(context))">Filter</MudButton>
            </FilterTemplate>
            <GroupTemplate>
                <span style="font-weight: bold">Level: @context.Grouping.Key <MudChip Color="Color.Info" Variant="Variant.Outlined">total: @context.Grouping.Count()</MudChip></span>
            </GroupTemplate>
        </PropertyColumn>

        <TemplateColumn Filterable="false" ShowColumnOptions="false" ShowFilterIcon="false" Title="Name" Sortable="true" SortBy="spell => spell.Spell.Name">
            <CellTemplate>
                <SpellLink SpellDisplay="@context.Item"/>
            </CellTemplate>
        </TemplateColumn>
        
        @if (typeof(TDisplay) == typeof(Pathfinder1SpellDisplay))
        {
            <PropertyColumn T="Pathfinder1SpellDisplay" TProperty="string" Title="School" Property="arg => arg.SchoolDisplay"/>
        }
        
        
        <PropertyColumn Title="Range/Targets" Property="arg => arg.RangeDisplay"/>
        
        <PropertyColumn Property="arg => arg.Spell.CastingTime" Title="Casting Time"/>
        <PropertyColumn Required="false" Property="spell => spell.Spell.Duration"/>

        
        
        @if (typeof(TDisplay) == typeof(Pathfinder1SpellDisplay))
        {
            <PropertyColumn T="Pathfinder1SpellDisplay" TProperty="string" Property="arg => arg.SpellResistDisplay" Title="Save/SR" Required="false"/>
            <PropertyColumn T="Pathfinder1SpellDisplay" TProperty="string" Required="false" Property="@(spell => spell.Spell.Components)"/>
        }

        
        <PropertyColumn Property="arg => arg.Spell.ShortDescription" Title="Description"/>
        <TemplateColumn Filterable="false" Sortable="false" ShowColumnOptions="false" ShowFilterIcon="false">
            <CellTemplate>
                <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="() => UnselectSpell(context.Item)">Remove</MudButton>
            </CellTemplate>
        </TemplateColumn>
        
        <TemplateColumn Filterable="false" Sortable="false" ShowColumnOptions="false" ShowFilterIcon="false">
            <CellTemplate>
                <MudIconButton Size="@Size.Small" Icon="@Icons.Material.Outlined.Edit" OnClick="@context.Actions.StartEditingItemAsync" />
            </CellTemplate>
        </TemplateColumn>
    </Columns>
    <ChildRowContent>
        @((MarkupString) context.Item.Spell.DescriptionFormatted)
    </ChildRowContent>
</MudDataGrid>

@code
{
    [Parameter, EditorRequired]
    public required ObservableCollection<TDisplay> Spells { get; set; }
    private MudDataGrid<TDisplay>? _spellGrid;
    private Dictionary<string, HashSet<TDisplay>> _filteredSpells = [];
    private FilterDefinition<TDisplay>? _filterDefinition;

    protected override void OnInitialized()
    {
        _filterDefinition = new FilterDefinition<TDisplay>
        {
            FilterFunction = x => _filteredSpells.Values.Any(set => set.Contains(x))
        };
    }

    public async Task SortByLevel()
    {
        if (_spellGrid is not null)
        {
            await _spellGrid.SetSortAsync(nameof(ISpellDisplay<TSpell>.CurrentSpellLevel), SortDirection.Ascending, x => x.CurrentSpellLevel, new MudBlazor.Utilities.NaturalComparer());
        }
    }
    

    private Task OnFilterChanged(string value, string propertyName)
    {
        var propertyInfo = typeof(TSpell).GetProperty(propertyName);

        if (propertyInfo is null)
        {
            return Task.CompletedTask;
        }
        
        foreach (var selectedSpell in Spells)
        {
            if (propertyInfo.GetValue(selectedSpell.Spell) is not string propertyValue)
            {
                continue; 
            }

            if (!propertyValue.Contains(value) && Fuzz.PartialRatio(value, propertyValue) <= 90) continue;

            if (!_filteredSpells.TryAdd(propertyName, [selectedSpell]))
            {
                _filteredSpells[propertyName].Add(selectedSpell);    
            }
        }
        return Task.CompletedTask;
    }
    
    private async Task ApplyFilterAsync(FilterContext<TDisplay> context)
    {
        if (_filterDefinition is null)
        {
            return;
        }
        await context.Actions.ApplyFilterAsync(_filterDefinition);
    }
    
    private Task UnselectSpell(TDisplay? spell)
    {
        if (spell is null)
        {
            return Task.CompletedTask; 
        }
        Spells.Remove(spell);
        return Task.CompletedTask;
    }
}
