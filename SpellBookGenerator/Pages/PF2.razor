@attribute [Route(Routes.Pathfinder2.Builder)]
@using System.Collections.Immutable
@using System.Collections.ObjectModel
@using FuzzySharp
@using Shared
@using SpellBookGenerator.Core
@using SpellBookGenerator.Core.RuleEngine
@using SpellBookGenerator.Core.Spells
@inject Pathfinder2SpellService SpellService
@inject IJsApiService JsService
@inject ISnackbar Snackbar

<MudStack Spacing="3">
    <MudCard>
        <MudCardContent>
            <MudStack Spacing="2">
                <MudToggleGroup ValuesChanged="@OnSelectedClassesChanged" T="CharacterClass.Pathfinder2" SelectionMode="SelectionMode.MultiSelection">
                    @foreach (var characterClass in Pathfinder2Extensions.GetValues())
                    {
                        <MudToggleItem T="CharacterClass.Pathfinder2" Value="characterClass">
                            <MudText Class="toggle-item-text">@characterClass.ToStringFast()</MudText>
                        </MudToggleItem>
                    }
                </MudToggleGroup>
                <MudDivider DividerType="DividerType.Middle"/>
                <MudToggleGroup @bind-Values="@_selectedTraditions" T="Tradition" SelectionMode="SelectionMode.MultiSelection">
                    @foreach (var tradition in TraditionExtensions.GetValues().Where(tradition => tradition != Tradition.All))
                    {
                        <MudToggleItem T="Tradition" Value="tradition">
                            <MudText Class="toggle-item-text">@tradition.ToStringFast()</MudText>
                        </MudToggleItem>
                    }
                </MudToggleGroup></MudStack>
        </MudCardContent>
    </MudCard>

    <MudStack Row Spacing="3">
        <MudCard Style="width: 40%">
            <MudCardHeader>
                <MudText Typo="Typo.h4" Color="Color.Primary">Direct Import</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudStack Spacing="2">
                    <MudAutocomplete
                        T="@Pathfinder2Spell"
                        SearchFuncWithCancel="@SearchSpell"
                        MinCharacters="3"
                        ResetValueOnEmptyText
                        CoerceText
                        ToStringFunc="spell => spell.Name"
                        ValueChanged="@OnSpellSelected"
                        ShowProgressIndicator
                        Placeholder="Light"
                        HelperText="Search by name"/>

                    <MudDivider DividerType="DividerType.Middle"/>

                    <MudTextField
                        Placeholder=
                        "Light
Fireball
Wish"
                        AutoGrow Lines="5" MaxLines="10" Variant="Variant.Outlined" @bind-Value="@_multiSPellNameImport"/>
                </MudStack>
            </MudCardContent>
            <MudCardActions>
                <MudButton OnClick="@(() => AddSpellsByName(_multiSPellNameImport))" Variant="Variant.Filled" Color="Color.Primary">Add Spells</MudButton>
            </MudCardActions>
        </MudCard>


        <MudCard Style="width: 100%">
            <MudCardHeader>
                <MudText Color="Color.Primary" Typo="Typo.h4">Search</MudText>
            </MudCardHeader>

            <MudCardContent>
                <MudStack Spacing="1">
                    <RuleCollection QueryableIntegers="Pathfinder2SpellDisplay.QueryableIntegers" QueryableStrings="Pathfinder2SpellDisplay.QueryableStrings" TSpell="Pathfinder2Spell" TDisplay="Pathfinder2SpellDisplay" RuleBuilder="@_ruleBuilder"/>
                    <MudDivider DividerType="DividerType.Middle"/>
                    <SpellGrid TSpell="Pathfinder2Spell" TDisplay="Pathfinder2SpellDisplay" Spells="@_ruleBuilderFoundSpells">
                        <AdditionalButtons>
                            <MudIconButton Icon="@Icons.Material.Filled.AddCircleOutline" Variant="Variant.Filled" Color="Color.Success" OnClick="@(() => AddSingleSpellFromSearch(context))"/>
                        </AdditionalButtons>
                    </SpellGrid>
                </MudStack>
            </MudCardContent>

            <MudCardActions>
                <MudButtonGroup OverrideStyles="false">
                    <MudButton OnClick="@SearchSpellsWithRuleBuilder" Variant="Variant.Filled" Color="Color.Success">Search Spells</MudButton>
                    <MudButton OnClick="@AddSpellsFoundSpells" Variant="Variant.Filled" Color="Color.Success" Disabled="@(!_ruleBuilderFoundSpells.Any())">Add Spells</MudButton>
                    <MudButton OnClick="() => _ruleBuilder = new AllRulesCollectionBuilder<Pathfinder2SpellDisplay>(Guid.NewGuid())" Variant="Variant.Filled" Color="Color.Error">Clear Rules</MudButton>
                </MudButtonGroup>
            </MudCardActions>
        </MudCard></MudStack>

    <MudCard>
        <MudCardContent>
            <SpellGrid @ref="@_mainSpellGrid" TDisplay="Pathfinder2SpellDisplay" TSpell="Pathfinder2Spell" Spells="_selectedSpells"></SpellGrid>
        </MudCardContent>
        <MudCardActions>
            <MudButtonGroup OverrideStyles="false">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@ExportNames">Export</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled>Print</MudButton>
                <MudButton OnClick="@(_selectedSpells.Clear)" Variant="Variant.Filled" Color="Color.Error">Clear List</MudButton>
            </MudButtonGroup>
        </MudCardActions>
    </MudCard></MudStack>


@code {
    private readonly ObservableCollection<Pathfinder2SpellDisplay> _selectedSpells = [];
    private List<CharacterClass.Pathfinder2> _selectedClasses = [];
    private IEnumerable<Tradition> _selectedTraditions = [];
    private string _multiSPellNameImport = "";
    private SpellGrid<Pathfinder2Spell, Pathfinder2SpellDisplay>? _mainSpellGrid;
    private RulesCollectionBuilderBase<Pathfinder2SpellDisplay> _ruleBuilder = new AllRulesCollectionBuilder<Pathfinder2SpellDisplay>(Guid.NewGuid());
    private ObservableCollection<Pathfinder2SpellDisplay> _ruleBuilderFoundSpells = [];


    private async Task<IEnumerable<Pathfinder2Spell>> LoadSpells(CancellationToken ctx = default)
    {
        var spells = await SpellService.GetAllSpells(ctx);

        List<Func<Pathfinder2Spell, bool>> rules = [];
        if (_selectedClasses.Any())
        {
            bool SelectedClassRule(Pathfinder2Spell spell) => 
                spell.Traits.Any(trait => Pathfinder2Extensions.TryParse(trait, out _, true, true));
            rules.Add(SelectedClassRule);
        }

        if (_selectedTraditions.Any())
        {
            bool SelectedTraditionsRule(Pathfinder2Spell spell) =>
                spell.Traditions.Contains(Tradition.All) ||
                spell.Traditions.Intersect(_selectedTraditions).Any();
            rules.Add(SelectedTraditionsRule);
        }

        return spells
            .Where(spell => 
                rules.Any(rule => rule(spell)));
    }

    private void AddSelectedTradition(IEnumerable<Tradition> traditionsToAdd)
    {
        var currentTraditions = traditionsToAdd.ToList();
        currentTraditions.AddRange(_selectedTraditions);
        _selectedTraditions = currentTraditions;
    }
    
    private void OnSelectedClassesChanged(IEnumerable<CharacterClass.Pathfinder2> selectedClassesEnumerable)
    {
        _selectedClasses = selectedClassesEnumerable.ToList();
        AddSelectedTradition(_selectedClasses.Select(selectedClass => selectedClass.GetTradition()));
    }
    
    private async Task ExportNames()
    {
        var names = _selectedSpells.Select(s => s.Spell.Name);
        var exportString = string.Join("\n", names);
        await JsService.CopyToClipboardAsync(exportString);
        Snackbar.Add("Names Copied!", Severity.Success);
    }
    
    private async Task AddSpellsByName(string spellNames)
    {
        var spells = await SpellService.GetAllSpells();
        var spellsArray = spells.ToImmutableArray();

        var singleSpellNames = spellNames
            .Split("\n")
            .Select(s => s.Replace("\"", ""))
            .Select(s => s.Trim());

        foreach (var spellName in singleSpellNames)
        {
            var spell = spellsArray.FirstOrDefault(spell => Fuzz.Ratio(spellName, spell.Name) >= 90);

            if (spell is null)
            {
                Snackbar.Add($"Could not find: {spellName}", Severity.Warning);
                continue;
            }

            _selectedSpells.Add(new Pathfinder2SpellDisplay(spell));
        }

        if (_mainSpellGrid is not null)
        {
            await _mainSpellGrid.SortByLevel();
        }
    }
    
    private Task OnSpellSelected(Pathfinder2Spell? spell)
    {
        if (spell is not null)
        {
            _selectedSpells.Add(new Pathfinder2SpellDisplay(spell));
            Snackbar.Add($"Added {spell.Name}", Severity.Success);
        }

        return Task.CompletedTask;
    }
    
    private async Task<IEnumerable<Pathfinder2Spell>> SearchSpell(string spellName, CancellationToken ctx)
    {
        var spells = await LoadSpells(ctx);
        return spells.Where(spell => Fuzz.Ratio(spellName, spell.Name) > 70).Take(5).OrderBy(spell => spell.Name);
    }

    private async Task SearchSpellsWithRuleBuilder()
    {
        var spells = LoadSpells();
        var rule = _ruleBuilder.Build();
        var foundSpells = (await spells).Select(spell => new Pathfinder2SpellDisplay(spell)).Where(display => rule(display)).ToImmutableArray();
        _ruleBuilderFoundSpells = new ObservableCollection<Pathfinder2SpellDisplay>(foundSpells);
    }


    private void AddSpellsFoundSpells()
    {
        foreach (var spell in _ruleBuilderFoundSpells)
        {
            _selectedSpells.Add(spell);
        }
        _ruleBuilderFoundSpells.Clear();
    }

    private void AddSingleSpellFromSearch(Pathfinder2SpellDisplay spell)
    {
        _selectedSpells.Add(spell);
        _ruleBuilderFoundSpells.Remove(spell);
    }

}

<style>
    .toggle-item-text{
        word-break: break-word;
    }
</style>