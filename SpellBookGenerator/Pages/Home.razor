@page "/"
@using System.Collections.ObjectModel
@using System.Text.RegularExpressions
@using FuzzySharp
@using Shared
@inject SpellService SpellService
@inject ISnackbar SnackBar
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject NavigationManager NavManager
@inject LoadingService LoadingService

<MudText Color="Color.Primary" Typo="Typo.h2">Pathfinder Spell Book Generator</MudText>

<MudCard Style="margin-bottom: 2rem">
    <MudCardContent>
        <MudText>
            To select spell you need to select a class first. This class will be used to determine the grade of your spells.
            If you select spells that aren't on your spell list, or choose "AllSpells" as your class, the lowest available grade will be chosen.
            Changing your selected class will only affect newly added spells!
            You can change all details on every spell in the preview table down below.
        </MudText>
        <MudStack Row>
            <MudSelect @ref="@_spellListSelect" Variant="Variant.Filled" HelperText="Select a Class" T="@CharacterClass" @bind-Value="@_mainSpellList" SelectedValuesChanged="@OnMainSelectionChanged">
                @foreach (var classList in Enum.GetValues<CharacterClass>())
                {
                    <MudSelectItem T="CharacterClass" Value="classList"></MudSelectItem>
                }
            </MudSelect>

            <MudSelect Variant="Variant.Filled" HelperText="Spell data to load" @ref="_spellListToLoadSelect" MultiSelection @bind-SelectedValues="@_selectedSpellLists" Style="margin-right: 2rem">
                @foreach (var classList in Enum.GetValues<CharacterClass>().OrderBy(classes => classes.ToString()))
                {
                    <MudSelectItem Value="classList"/>
                }
            </MudSelect>
        </MudStack>

    </MudCardContent>
</MudCard>


@if (_selectedSpellLists.Any())
{
        <MudGrid Justify="Justify.SpaceEvenly" Spacing="3" Style="margin-bottom: 2rem">
            <MudCard Style="width: 40%">
                <MudCardHeader>
                    <MudText Typo="Typo.h3" Color="Color.Primary">Mass Import</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudTextField 
                        Placeholder
                        =
                        "Light
Fireball
Wish" 
                        AutoGrow Lines="5" MaxLines="10" Variant="Variant.Outlined" @bind-Value="@_massImport"/>
                </MudCardContent>
                <MudCardActions>
                    <MudButton OnClick="@(() => CheckSpells(_massImport))" Variant="Variant.Filled" Color="Color.Primary">Add Spells</MudButton>
                </MudCardActions>
            </MudCard>
            <MudCard Style="width: 40%">
                <MudCardHeader>
                    <MudText Typo="Typo.h3" Color="Color.Primary">Spell Search</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudStack Justify="Justify.SpaceBetween">
                        <MudAutocomplete
                            T="Spell"
                            SearchFuncWithCancel="@SearchSpell"
                            MinCharacters="3"
                            ResetValueOnEmptyText
                            CoerceText
                            ToStringFunc="spell => spell.Name"
                            ValueChanged="@OnSpellSelected"
                            ShowProgressIndicator/>
                        
                        <div>
                            <MudText>You can also add all spells that match some custom expression</MudText>
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => _spellFilterAddDialogOpen = true)">Add spells using expression</MudButton>
                        </div>
                    </MudStack>
                </MudCardContent>
            </MudCard>
        </MudGrid>
}

<MudCard>
    <MudCardContent>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@GoToPrint">Print</MudButton>
        <MudDataGrid 
            ReadOnly="false" 
            EditMode="DataGridEditMode.Form" 
            @ref="@_spellGrid" 
            Groupable 
            GroupExpanded="false"
            
            Items="_selectedSpells"
            
            Filterable
            FilterCaseSensitivity="DataGridFilterCaseSensitivity.Ignore"
            FilterMode="DataGridFilterMode.Simple"
            >
            <Columns>
                <HierarchyColumn/>
                <PropertyColumn Title="Level" IsEditable Property="arg => arg.CurrentSpellGrade" Grouping GroupBy="spell => spell.CurrentSpellGrade">
                    <FilterTemplate>
                        <MudTextField T="string" ValueChanged="@((string value) => OnFilterChanged(value, nameof(Spell.Name)))"/>
                        <MudButton OnClick="@(() => ApplyFilterAsync(context))">Filter</MudButton>
                    </FilterTemplate>
                    <GroupTemplate>
                        <span style="font-weight: bold">Level: @context.Grouping.Key <MudChip Color="Color.Info" Variant="Variant.Outlined">total: @context.Grouping.Count()</MudChip></span>
                    </GroupTemplate>
                </PropertyColumn>

                <TemplateColumn Filterable="false" ShowColumnOptions="false" ShowFilterIcon="false" Title="Name" Sortable="true" SortBy="spell => spell.Spell.Name">
                    <CellTemplate>
                        <SpellLink SpellName="@context.Item.Spell.Name"/>
                    </CellTemplate>
                </TemplateColumn>
                
                <PropertyColumn Title="School" Property="arg => arg.SchoolDisplay"/>
                
                <PropertyColumn Title="Range/Targets" Property="arg => arg.RangeDisplay"/>
                
                <PropertyColumn Property="arg => arg.Spell.CastingTime" Title="Casting Time"/>
                <PropertyColumn Required="false" Property="spell => spell.Spell.Duration"/>

                <PropertyColumn Property="arg => arg.SpellResistDisplay" Title="Save/SR" Required="false"/>
                
                
                <PropertyColumn Required="false" Property="arg => arg.Spell.Components"/>
                <PropertyColumn Property="arg => arg.Spell.ShortDescription" Title="Description"/>
                <TemplateColumn Filterable="false" Sortable="false" ShowColumnOptions="false" ShowFilterIcon="false">
                    <CellTemplate>
                        <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="() => UnselectSpell(context.Item)">Remove</MudButton>
                    </CellTemplate>
                </TemplateColumn>
                
                <TemplateColumn Filterable="false" Sortable="false" ShowColumnOptions="false" ShowFilterIcon="false">
                    <CellTemplate>
                        <MudIconButton Size="@Size.Small" Icon="@Icons.Material.Outlined.Edit" OnClick="@context.Actions.StartEditingItemAsync" />
                    </CellTemplate>
                </TemplateColumn>
            </Columns>
            <ChildRowContent>
                @((MarkupString) context.Item.Spell.DescriptionFormatted)
            </ChildRowContent>
        </MudDataGrid>
    </MudCardContent>
    <MudCardActions>
        <MudButton OnClick="@(_selectedSpells.Clear)" Variant="Variant.Filled" Color="Color.Error">Clear List</MudButton>
    </MudCardActions>
</MudCard>

@code
{
    private Dictionary<string, HashSet<SelectedSpell>> _filteredSpells = [];

    private FilterDefinition<SelectedSpell>? _filterDefinition;

    private Task OnFilterChanged(string value, string propertyName)
    {
        var propertyInfo = typeof(Spell).GetProperty(propertyName);

        if (propertyInfo is null)
        {
            return Task.CompletedTask;
        }
        
        foreach (var selectedSpell in _selectedSpells)
        {
            var propertyValue = propertyInfo.GetValue(selectedSpell.Spell) as string;
            if (propertyValue is null)
            {
                continue; 
            }

            if (!propertyValue.Contains(value) && Fuzz.PartialRatio(value, propertyValue) <= 90) continue;

            if (!_filteredSpells.TryAdd(propertyName, [selectedSpell]))
            {
                _filteredSpells[propertyName].Add(selectedSpell);    
            }
        }
        return Task.CompletedTask;
    }

    private async Task ApplyFilterAsync(FilterContext<SelectedSpell> context)
    {
        if (_filterDefinition is null)
        {
            return;
        }
        await context.Actions.ApplyFilterAsync(_filterDefinition);
    }
}


<MudDialog @bind-IsVisible="@_spellFilterAddDialogOpen" Options="@_spellFilterAddDialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6" Color="Color.Primary">Filter spell add</MudText>
    </TitleContent>
    <DialogContent>
        <MudForm Model="@_spellFilterAddModel">
            <MudStack Row AlignItems="AlignItems.Baseline">
                <MudNumericField @bind-Value="@_spellFilterAddModel.MinimumSpellLevel" Variant="Variant.Filled" Min="0" Max="9" HelperText="Min. Spell Level"/>
                -
                <MudNumericField @bind-Value="@_spellFilterAddModel.MaximumSpellLevel" Variant="Variant.Filled" Min="0" Max="9" HelperText="Max. Spell Level"/>
            </MudStack>
            <MudStack Row AlignItems="AlignItems.Baseline">
                <MudTextField @bind-Value="@_spellFilterAddModel.FilterExpression" Variant="Variant.Filled" HelperText="Filter Expression"/>
                <MudTooltip Text="This filter accepts regex expressions.">
                    <MudIcon Icon="@Icons.Material.Filled.Help"/>
                </MudTooltip>
            </MudStack>
            <MudToggleGroup @bind-Values="@_spellFilterAddModel.SearchFields" T="SearchField" SelectionMode="SelectionMode.MultiSelection" CheckMark Color="Color.Primary">
                @foreach (var field in Enum.GetValues<SearchField>())
                {
                    <MudToggleItem Text="@(field.ToStringFast())" Value="@field" UnselectedIcon="@Icons.Material.Filled.CheckBoxOutlineBlank" SelectedIcon="@Icons.Material.Filled.CheckBox"/>
                }
            </MudToggleGroup>
        </MudForm>
        @if (_filterAddFoundSpells.Any())
        {
            <MudPaper>
                <MudList>
                    @foreach (var foundSpell in _filterAddFoundSpells)
                    {
                        <MudListItem>@foundSpell.Spell.Name (@foundSpell.CurrentSpellGrade)</MudListItem>
                        <MudDivider/>
                    }
                </MudList>
            </MudPaper>
        }
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Warning" OnClick="@(() => _spellFilterAddDialogOpen = false)">Cancel</MudButton>
        <MudTooltip ShowOnHover="@(!_spellFilterAddModel.SearchFields.Any())" Text="Please select at least one text to search in">
            <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="@(() => FilterSpells(_spellFilterAddModel))" Disabled="@(!_spellFilterAddModel.SearchFields.Any())">Search Spells</MudButton>
        </MudTooltip>
        @if(_filterAddFoundSpells.Any())
        {
            <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="@AddFoundFilteredSpells">Add Spells</MudButton>
        }
    </DialogActions>
</MudDialog>


@code
{
    private string _massImport = "";
    private readonly ObservableCollection<SelectedSpell> _selectedSpells = [];
    private MudDataGrid<SelectedSpell>? _spellGrid;
    private CharacterClass _mainSpellList;
    private MudSelect<CharacterClass>? _spellListToLoadSelect;
    
    
    private MudSelect<CharacterClass>? _spellListSelect;

    private DialogOptions _spellFilterAddDialogOptions = new()
    {
        CloseButton = true,
        CloseOnEscapeKey = true,
        MaxWidth = MaxWidth.ExtraLarge
    };
    private bool _spellFilterAddDialogOpen;
    private SpellFilterModel _spellFilterAddModel = new();
    private List<SelectedSpell> _filterAddFoundSpells = [];
    private IEnumerable<CharacterClass> _selectedSpellLists = [];

    protected override async void OnInitialized()
    {
        _filterDefinition = new FilterDefinition<SelectedSpell>
        {
            FilterFunction = x => _filteredSpells.Values.Any(set => set.Contains(x))
        };
        
        var spells = await LocalStorage.GetItemAsync<List<SelectedSpell>>("spells");
        if (spells is null)
        {
            return;
        }
        
        foreach (var spell in spells)
        {
            _selectedSpells.Add(spell);
        }
    }

    private Task UnselectSpell(SelectedSpell? spell)
    {
        if (spell is null)
        {
            return Task.CompletedTask; 
        }
        _selectedSpells.Remove(spell);
        return Task.CompletedTask;
    }

    private async Task CheckSpells(string spellNames)
    {
        var spells = (await SpellService.GetSpellsAsync(_selectedSpellLists)).ToList();

        var singleSpellNames = spellNames
            .Split("\n")
            .Select(s => s.Replace("\"", ""))
            .Select(s => s.Trim());

        foreach (var spellName in singleSpellNames)
        {
            var spell = spells.FirstOrDefault(spell => Fuzz.Ratio(spellName, spell.Name) >= 90);

            if (spell is null)
            {
                SnackBar.Add($"Could not find: {spellName}", Severity.Warning);
                continue;
            }
            
            _selectedSpells.Add(new SelectedSpell(spell, _mainSpellList));
        }

        if (_spellGrid is not null)
        {
            await _spellGrid.SetSortAsync(nameof(SelectedSpell.CurrentSpellGrade), SortDirection.Ascending, x => x.CurrentSpellGrade, new MudBlazor.Utilities.NaturalComparer());
        }
    }

    private async Task GoToPrint()
    {
        await LocalStorage.SetItemAsync("spells", _selectedSpells);
        var returnUri = NavManager.ToBaseRelativePath(NavManager.Uri);
        NavManager.NavigateTo($"print?returnPath={returnUri}");
    }

    private async Task<IEnumerable<Spell>> SearchSpell(string spellName, CancellationToken ctx)
    {
        var spells = await SpellService.GetSpellsAsync(_selectedSpellLists, ctx);
        return spells.Where(spell => Fuzz.Ratio(spellName, spell.Name) > 70).Take(5).OrderBy(spell => spell.Name);
    }

    private Task OnSpellSelected(Spell? spell)
    {
        if (spell is not null)
        {
            _selectedSpells.Add(new SelectedSpell(spell, _mainSpellList));
        }
        
        return Task.CompletedTask;
    }


    private Task OnMainSelectionChanged(IEnumerable<CharacterClass> arg)
    {
        return _spellListToLoadSelect?.SelectOption(arg.First()) ?? Task.CompletedTask;
    }

    private async Task FilterSpells(SpellFilterModel filter)
    {
        var pattern = new Regex(filter.FilterExpression);

        var spells = await SpellService.GetSpellsAsync(_selectedSpellLists);
        var spellQuery = spells
            .Select(s => new SelectedSpell(s, _mainSpellList))
            .Where(spell => spell.CurrentSpellGrade >= filter.MinimumSpellLevel && spell.CurrentSpellGrade <= filter.MaximumSpellLevel)
            .Where(selectedSpell => 
                
                filter.SearchFields.Select(field => 
                    GetField(field, selectedSpell.Spell))
                    .Any(fieldContent => pattern.IsMatch(fieldContent)
                ))
            .OrderBy(s => s.CurrentSpellGrade);

        

        _filterAddFoundSpells = spellQuery.ToList();
    }

    private string GetField(SearchField searchField, Spell spell)
    {
        return searchField switch
        {
            SearchField.Name => spell.Name,
            SearchField.ShortDescription => spell.ShortDescription,
            SearchField.FullDescription => spell.DescriptionFormatted,
            SearchField.Range => spell.Range,
            _ => throw new ArgumentOutOfRangeException(nameof(searchField), searchField, null)
        };
    }

    private Task AddFoundFilteredSpells()
    {
        foreach (var foundSpell in _filterAddFoundSpells)
        {
            _selectedSpells.Add(foundSpell);
        }
        
        _filterAddFoundSpells.Clear();
        _spellFilterAddModel = new();
        _spellFilterAddDialogOpen = false;
        return Task.CompletedTask;
    }
}


